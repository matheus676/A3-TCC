package com.portugol.parser;

import com.portugol.ast.*;
import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;

parser code {:
   @Override
    public void syntax_error(Symbol s) {
        String lexema = (s.value != null) ? s.value.toString() : sym.terminalNames[s.sym];
        System.err.println("Erro de Sintaxe na linha " + (s.left + 1) + 
                           ", coluna " + (s.right + 1) + 
                           ". Encontrado: " + lexema);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        System.err.println("Erro Fatal: Não foi possível recuperar a análise após o erro na linha " + 
                           (s.left + 1) + ".");
        throw new Exception("Erro Fatal de Sintaxe"); 
    }
:}

// 1. Definição dos Terminais
terminal SE, ENTAO, SENAO;
terminal TIPO_INT, TIPO_BOOL, TIPO_VOID;
terminal FUNCAO, RETORNE, VIRGULA, FACA, ENQUANTO, PARA, MAIS, MENOS, MENOR, MULT, DIV, MAIOR, IGUAL, AP, FP, PV, FIM;
terminal String ID, NUM;

// 2. Definição dos Não-Terminais
// Todos retornam objetos da árvore (Node, Expressao, Bloco)
non terminal Bloco lista_cmds;
non terminal Atribuicao atribuicao;
non terminal Node cmd;
non terminal Expressao expr, condicao;

non terminal Programa programa;
non terminal List<FuncaoDeclaracao> lista_funcoes;
non terminal FuncaoDeclaracao funcao;
non terminal List<Parametro> params;
non terminal Parametro parametro; 
non terminal Tipo tipo;
non terminal Node declaracao;
non terminal List<Expressao> args;


// 3. Precedência
precedence left ENTAO;
precedence left SENAO;
precedence left MAIOR;
precedence left MAIS, MENOS;
precedence left MULT, DIV;

start with programa;

// 4. Gramática

programa ::= lista_funcoes:l 
           {: RESULT = new Programa(l); :};

lista_funcoes ::= lista_funcoes:l funcao:f 
                {: l.add(f); RESULT = l; :}
                | funcao:f 
                {: 
                   List<FuncaoDeclaracao> l = new ArrayList<>();
                   l.add(f); 
                   RESULT = l; 
                :};

tipo ::= TIPO_INT   {: RESULT = Tipo.INTEIRO; :}
       | TIPO_BOOL  {: RESULT = Tipo.BOOLEANO; :}
       | TIPO_VOID  {: RESULT = Tipo.VAZIO; :};

funcao ::= FUNCAO tipo:t ID:nome AP params:p FP FACA lista_cmds:corpo FIM
         {: 
            RESULT = new FuncaoDeclaracao(t, nome, p, corpo);
         :};

params ::= parametro:p VIRGULA params:lista 
         {: lista.add(0, p); RESULT = lista; :}
         | parametro:p 
         {: 
            List<Parametro> l = new ArrayList<>();
            l.add(p);
            RESULT = l; 
         :}
         | /* Vazio */ 
         {: RESULT = new ArrayList<Parametro>(); :};

parametro ::= tipo:t ID:nome 
            {: RESULT = new Parametro(t, nome); :};

lista_cmds ::= lista_cmds:l cmd:c 
             {: l.adicionar(c); RESULT = l; :}
             | cmd:c 
             {: Bloco b = new Bloco(); b.adicionar(c); RESULT = b; :};            

    

declaracao ::= tipo:t ID:id IGUAL expr:e 
             {: 
                RESULT = new DeclaracaoVariavel(t, id, e); 
             :};

atribuicao ::= ID:id IGUAL expr:e {: RESULT = new Atribuicao(id, e); :}
             | ID:id IGUAL condicao:c {: RESULT = new Atribuicao(id, c); :};

args ::= expr:e VIRGULA args:a {: a.add(0, e); RESULT = a; :}
       | expr:e {: List<Expressao> l = new ArrayList<>(); l.add(e); RESULT = l; :}
       | /* Vazio */ {: RESULT = new ArrayList<Expressao>(); :};             

cmd ::= 
    RETORNE expr:e PV {: RESULT = new Retorno(e); :}
    
    | declaracao:d PV {: RESULT = d; :}
    | atribuicao:a PV {: RESULT = a; :}
    
    | SE AP condicao:c FP ENTAO cmd:t SENAO cmd:e 
      {: RESULT = new CondicaoSe(c, t, e); :}
    | SE AP condicao:c FP ENTAO cmd:t 
      {: RESULT = new CondicaoSe(c, t, null); :}
    
    | ENQUANTO AP condicao:c FP FACA lista_cmds:body FIM
      {: RESULT = new Enquanto(c, body); :}
   
    | PARA AP atribuicao:init PV condicao:cond PV atribuicao:inc FP FACA lista_cmds:body FIM
      {: RESULT = new Para(init, cond, inc, body); :};

// Expressões
expr ::= expr:e1 MAIS expr:e2 
       {: RESULT = new ExpressaoBinaria(e1, e2, Operador.SOMA); :}
       
       | expr:e1 MENOS expr:e2 
       {: RESULT = new ExpressaoBinaria(e1, e2, Operador.SUB); :}
       
       | expr:e1 MULT expr:e2 
       {: RESULT = new ExpressaoBinaria(e1, e2, Operador.MULT); :}
       
       | expr:e1 DIV expr:e2 
       {: RESULT = new ExpressaoBinaria(e1, e2, Operador.DIV); :}
       | NUM:n 
       {: 
          RESULT = new Numero(n); 
       :}
       |
       ID:nome AP args:a FP 
       {: RESULT = new FuncaoChamada(nome, a); :}
       | ID:id 
       {: 
          RESULT = new Variavel(id); 
       :};

condicao ::= expr:e1 MAIOR expr:e2 
           {: RESULT = new ExpressaoBinaria(e1, e2, Operador.MAIOR); 
           :}
           | expr:e1 MENOR expr:e2 
           {: RESULT = new ExpressaoBinaria(e1, e2, Operador.MENOR); 
           :}
           ;