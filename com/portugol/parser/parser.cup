package com.portugol.parser;

import com.portugol.ast.*;
import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;

// 1. Definição dos Terminais
terminal SE, ENTAO, SENAO;
terminal FUNCAO, RETORNE, VIRGULA, FACA, ENQUANTO, PARA, MAIS, MENOS, MENOR, MULT, DIV, MAIOR, IGUAL, AP, FP, PV;
terminal String ID, NUM;

// 2. Definição dos Não-Terminais
// Todos retornam objetos da árvore (Node, Expressao, Bloco)
non terminal Bloco programa, lista_cmds;
non terminal Atribuicao atribuicao;
non terminal Node cmd;
non terminal Expressao expr, condicao;

non terminal FuncaoDeclaracao funcao;
non terminal List<FuncaoDeclaracao> lista_funcoes;
non terminal List<String> params;
non terminal List<Expressao> args;

// 3. Precedência
precedence left ENTAO;
precedence left SENAO;

precedence left MAIOR;
precedence left MAIS, MENOS;
precedence left MULT, DIV;

start with lista_funcoes;

// 4. Gramática

lista_funcoes ::= lista_funcoes:l funcao:f 
                {: l.add(f); RESULT = l; :}
                | funcao:f 
                {: 
                   List<FuncaoDeclaracao> l = new ArrayList<>();
                   l.add(f); 
                   RESULT = l; 
                :};

funcao ::= FUNCAO ID:nome AP params:p FP FACA cmd:corpo
         {: 
            // O parser atual usa 'cmd' que retorna 'Node' ou 'Bloco'
            // Se 'cmd' retornar 'CondicaoSe' ou algo unico, precisamos garantir que seja um Bloco.
            // O ideal é que o corpo da função seja um Bloco { ... }
            RESULT = new FuncaoDeclaracao(nome, p, (Bloco)corpo); 
         :};

params ::= ID:id VIRGULA params:p 
         {: p.add(0, id); RESULT = p; :}
         | ID:id 
         {: 
            List<String> l = new ArrayList<>();
            l.add(id);
            RESULT = l; 
         :}
         | /* Vazio */ 
         {: RESULT = new ArrayList<String>(); :};

args ::= expr:e VIRGULA args:a 
       {: a.add(0, e); RESULT = a; :}
       | expr:e 
       {: 
          List<Expressao> l = new ArrayList<>();
          l.add(e);
          RESULT = l; 
       :}
       | /* Vazio */ 
       {: RESULT = new ArrayList<Expressao>(); :};         


atribuicao ::= ID:id IGUAL expr:e 
             {: RESULT = new Atribuicao(id, e); :}
             | ID:id IGUAL condicao:c 
             {: RESULT = new Atribuicao(id, c); :};

cmd ::= 
   RETORNE expr:e PV 
      {: RESULT = new Retorno(e); :}
    |   
    // Atribuição simples
    atribuicao:a PV 
    {: 
        RESULT = a; 
    :}    
    // Comando SE COM SENAO (Completo)
    |
    SE AP condicao:c FP ENTAO cmd:t SENAO cmd:e 
    {: 
        RESULT = new CondicaoSe(c, t, e); 
    :}

    // Comando SE SIMPLES (Novo!)
    |
    SE AP condicao:c FP ENTAO cmd:t 
    {: 
        // Passamos 'null' porque não existe bloco else
        RESULT = new CondicaoSe(c, t, null); 
    :}
    | ENQUANTO AP condicao:c FP FACA cmd:body 
      {: 
        RESULT = new Enquanto(c, body); 
      :}
     | PARA AP atribuicao:init PV condicao:cond PV atribuicao:inc FP FACA cmd:body
    {: 
       RESULT = new Para(init, cond, inc, body); 
    :}; 

// Expressões
expr ::= expr:e1 MAIS expr:e2 
       {: RESULT = new ExpressaoBinaria(e1, e2, Operador.SOMA); :}
       
       | expr:e1 MENOS expr:e2 
       {: RESULT = new ExpressaoBinaria(e1, e2, Operador.SUB); :}
       
       | expr:e1 MULT expr:e2 
       {: RESULT = new ExpressaoBinaria(e1, e2, Operador.MULT); :}
       
       | expr:e1 DIV expr:e2 
       {: RESULT = new ExpressaoBinaria(e1, e2, Operador.DIV); :}
       | NUM:n 
       {: 
          RESULT = new Numero(n); 
       :}
       |
       ID:nome AP args:a FP 
       {: RESULT = new FuncaoChamada(nome, a); :}
       | ID:id 
       {: 
          RESULT = new Variavel(id); 
       :};

condicao ::= expr:e1 MAIOR expr:e2 
           {: RESULT = new ExpressaoBinaria(e1, e2, Operador.MAIOR); 
           :}
           | expr:e1 MENOR expr:e2 
           {: RESULT = new ExpressaoBinaria(e1, e2, Operador.MENOR); 
           :}
           ;